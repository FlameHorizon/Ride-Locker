@page "/upload"
@rendermode InteractiveServer

@using System.Xml.Serialization
@using Microsoft.EntityFrameworkCore
@using System.Diagnostics
@using Website.Data
@using Website.Models

@inject ILogger<Upload> Logger
@inject IDbContextFactory<AppDbContext> DbContextFactory


<PageTitle>Upload files</PageTitle>

<InputFile OnChange="LoadFiles" multiple accept=".gpx" />

@if (_done) {
  <p>Done</p>
}

@code {
  private bool _done = false;
  private async Task LoadFiles(InputFileChangeEventArgs e)
  {
    const int MAX_FILE_COUNT = 10;
    int count = e.FileCount;
    if (count > MAX_FILE_COUNT)
    {
      // TODO: Implement information for user that the limit is 10.
      Logger.LogWarning("User attempted to upload {0} files, but count limit is {1}.",
      count,
      MAX_FILE_COUNT);
      return;
    }

    const int MAX_FILE_SIZE_BYTES = 1024 * 1024 * 1; // 1MB
    foreach (IBrowserFile file in e.GetMultipleFiles(count))
    {
      if (file.Size > MAX_FILE_SIZE_BYTES)
      {
        Logger.LogWarning("User attempted to upload file '{0}' of size {1}, but size limit is {2}. Aborting.",
        file.Name,
        file.Size,
        MAX_FILE_SIZE_BYTES);
        return;
      }

      string ext = Path.GetExtension(file.Name).ToLower();
      if (ext != ".gpx")
      {
        Logger.LogWarning("User attempted to upload file '{0}' with extension '{1}', but expected extension is '.gpx'. Aborting.",
        file.Name,
        ext);
        return;
      }
    }

    // PERF: Counters
    var sw = new Stopwatch();
    sw.Start();
    Logger.LogDebug("Loading {0} files.", count);
    List<Ride> rides = [];
    foreach (IBrowserFile file in e.GetMultipleFiles(count))
    {
      var serializer = new XmlSerializer(typeof(Gpx));
      var ms = new MemoryStream();
      await file.OpenReadStream(MAX_FILE_SIZE_BYTES).CopyToAsync(ms);

      ms.Position = 0;
      Gpx? gpx = serializer.Deserialize(ms) as Gpx;

      if (gpx is null)
      {
        Logger.LogWarning("Tried to deserailize file '{0}' into Gpx but got null as result. Aborting.", file.Name);
        return;
      }

      // TODO: GPX file has to be converted into Ride object.
      List<Trkpt> trackPoints = gpx.Trk.Trkseg.Trkpt;

      int trackPointCount = trackPoints.Count;
      DateTime start = trackPoints[0].Time;
      DateTime end = trackPoints[trackPointCount - 1].Time;

      double elevationGain = 0.0d;
      double elevationLoss = trackPoints[0].Ele;
      double elePrev = trackPoints[0].Ele;
      double maxSpeed = double.MinValue;

      double latPrev = trackPoints[0].Lat;
      double lonPrev = trackPoints[0].Lon;
      double distance = 0.0d;

      int fastAccelerationCount = 0;
      int fastDecelerationCount = 0;
      DateTime dtPrev = trackPoints[0].Time;
      // NOTE: First value might be also null.
      double? speedPrev = trackPoints[0].Extensions?.Speed;

      double sumSpeed = 0.0d;

      for (int i = 0; i < trackPoints.Count; i++)
      {
        if (trackPoints[i].Extensions is not null && speedPrev is not null)
        {
          // Accelerations and decelerationCount
          double dtSec = (trackPoints[i].Time - dtPrev).TotalSeconds;
          if (dtSec > 0)
          {
            double speedDelta = (trackPoints[i].Extensions.Speed - speedPrev.Value) / 3.6 / dtSec;
            if (speedDelta > 2.0d)
            {
              fastAccelerationCount++;
            }
            else if (speedDelta < -2.0d)
            {
              fastDecelerationCount++;
            }
          }
        }

        dtPrev = trackPoints[i].Time;
        speedPrev = trackPoints[i].Extensions?.Speed;

        // Speed and max speed.
        // NOTE: There are cases where speed value is not available.
        // Right now, to make visible I'm putting -1 as value.
        // In real case it would make more sense to copy previous data point.
        if (trackPoints[i].Extensions is not null)
        {
          maxSpeed = Math.Max(maxSpeed, trackPoints[i].Extensions.Speed);
          sumSpeed = trackPoints[i].Extensions.Speed;
        }

        // Elevation gain and loss.
        double diff = elePrev - trackPoints[i].Ele;
        if (diff > 0.0d)
        {
          elevationGain += diff;
        }
        else
        {
          elevationLoss -= diff;
        }
        elePrev = trackPoints[i].Ele;

        // Distnace
        distance += Geo.HaversineDistance(latPrev, lonPrev, trackPoints[i].Lat, trackPoints[i].Lon);
        latPrev = trackPoints[i].Lat;
        lonPrev = trackPoints[i].Lon;
      }

      //int fastAccelerationCount = DriverDynamics.AccelerationsRates(xs, ys).Count(x => x >= 2.0);
      //int fastDecelerationCount = DriverDynamics.DecelerationsRates(xs, ys).Count(x => x <= -2.0);
      double avgSpeed = sumSpeed / trackPointCount;

      var ride = new Ride
      {
        Start = start,
        End = end,
        TrackPointCount = trackPointCount,
        Distance = distance,
        ElevationGain = elevationGain,
        ElevationLoss = elevationLoss,
        FastAccelerationCount = fastAccelerationCount,
        FastDecelerationCount = fastDecelerationCount,
        MaxSpeed = maxSpeed,
        AvgSpeed = avgSpeed
      };

      rides.Add(ride);
    }
    
    await using AppDbContext db = await DbContextFactory.CreateDbContextAsync();
    db.Rides.AddRange(rides);
    await db.SaveChangesAsync();
    sw.Stop();
    Logger.LogDebug("Took {0} ms to process {1} files.", sw.ElapsedMilliseconds, count);
    _done = true;
  }

  private static double GetElevationLoss(List<Trkpt> points)
  {
    double res = 0.0;
    for (int i = 1; i < points.Count; i++)
    {
      double diff = points[i].Ele - points[i - 1].Ele;
      if (diff < 0.0)
      {
        res += diff;
      }
    }

    return res;
  }

  private static double GetElevationGain(List<Trkpt> points)
  {
    double res = 0.0;
    for (int i = 1; i < points.Count; i++)
    {
      double diff = points[i].Ele - points[i - 1].Ele;
      if (diff > 0.0)
      {
        res += diff;
      }
    }

    return res;
  }

}